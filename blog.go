// Package main provides a build tool for Hugo blogs with D2 diagram support and resume PDF generation.
//
// # Overview
//
// This tool automatically:
//   - Renders D2 diagram files (.d2) to SVG format for use in Hugo sites
//   - Generates a PDF version of your resume from content/resume/index.md
// It integrates with Hugo's build and development workflow to provide live reloading of diagrams.
//
// # D2 Integration
//
// D2 (https://d2lang.com) is a declarative diagram language. This tool:
//   - Finds all .d2 files in the Hugo content directory
//   - Renders them to .svg files in the same location
//   - Reads rendering options from Hugo's config.toml [params.d2] section
//   - Watches for changes and re-renders automatically in development mode
//
// # Assumptions
//
//   - The d2 command-line tool is installed and available in PATH
//   - Chrome/Chromium browser is installed (for PDF generation)
//   - Hugo content lives in a 'content/' directory
//   - Hugo config is in 'config.toml' at the project root
//   - Generated .svg files and resume.pdf are git-ignored (only sources are committed)
//   - D2 files use the Hugo shortcode: {{< d2 src="diagram.d2" >}}
//   - Resume content is at content/resume/index.md
//
// # Usage
//
//	# Render all D2 files and generate resume PDF (for production builds)
//	go run blog.go
//
//	# Development mode: start Hugo server with D2 watching
//	go run blog.go --serve
//
//	# Watch D2 files only (without Hugo server)
//	go run blog.go --watch
//
//	# Show detailed rendering output
//	go run blog.go --verbose
//
// # Resume PDF Generation
//
// The tool automatically generates a PDF from content/resume/index.md:
//   - Watches public/resume/index.html (generated by Hugo)
//   - Uses headless Chrome to render the HTML file with your theme's styling
//   - Saves the PDF to public/resume.pdf (served at /resume.pdf)
//   - Regenerates automatically when the resume HTML changes
//   - PDF preserves text as searchable text (ATS-compatible)
//   - public/ directory is git-ignored, including the generated PDF
//
// Build workflow:
//   1. go run blog.go          # Renders D2 files
//   2. hugo --gc --minify      # Builds site including resume HTML
//   3. go run blog.go          # Generates PDF from built HTML
//
// # Configuration
//
// D2 rendering options are read from config.toml:
//
//	[params.d2]
//	    theme = "1"        # D2 theme ID (0-8) or name
//	    layout = "elk"     # Layout engine: elk, dagre, etc.
//	    sketch = false     # Hand-drawn style
//	    pad = 10           # Padding in pixels
//
// # Integration with Hugo
//
// In development (--serve mode):
//  1. Renders all D2 files initially
//  2. Starts Hugo dev server
//  3. Watches for D2 file changes and re-renders
//  4. Hugo detects SVG changes and triggers browser reload
//
// In production (CI/CD):
//  1. Run 'go run blog.go' to render all diagrams
//  2. Run 'hugo' to build the site with the generated SVGs
//
// # File Watching
//
// The tool watches:
//   - All .d2 files in content/ → re-renders individual file on change
//   - config.toml → re-renders ALL diagrams if D2 config changes
//   - New directories created in content/ → automatically adds to watch list
//
// Changes are debounced (300ms) to avoid multiple renders during rapid edits.
package main

import (
	"context"
	"flag"
	"fmt"
	"log"
	"os"
	"os/exec"
	"os/signal"
	"path/filepath"
	"strings"
	"sync"
	"syscall"
	"time"

	"github.com/BurntSushi/toml"
	"github.com/chromedp/cdproto/page"
	"github.com/chromedp/chromedp"
	"github.com/fsnotify/fsnotify"
)

// Config represents the Hugo config.toml structure containing D2 rendering settings.
// Only the [params.d2] section is parsed; other Hugo settings are ignored.
type Config struct {
	Params struct {
		D2 struct {
			Theme  string `toml:"theme"`  // D2 theme ID or name (e.g., "1", "cool-classics")
			Layout string `toml:"layout"` // Layout engine (e.g., "elk", "dagre")
			Sketch bool   `toml:"sketch"` // Enable hand-drawn sketch style
			Pad    int    `toml:"pad"`    // Padding in pixels around diagrams
		} `toml:"d2"`
	} `toml:"params"`
}

func main() {
	// Define flags
	serve := flag.Bool("serve", false, "Run Hugo dev server with D2 watching")
	watch := flag.Bool("watch", false, "Watch D2 files only (no Hugo server)")
	verbose := flag.Bool("verbose", false, "Show detailed output")
	flag.Parse()

	// Ensure d2 is installed
	if !commandExists("d2") {
		log.Fatal("d2 is not installed. Install: curl -fsSL https://d2lang.com/install.sh | sh -s --")
	}

	// Load Hugo config to get D2 settings
	config := loadConfig("config.toml")

	// Render all D2 files initially
	if err := renderAll("content", config, *verbose); err != nil {
		log.Fatalf("Failed to render D2 files: %v", err)
	}

	// Try to generate resume PDF if public/resume/index.html exists
	// (This handles the case where Hugo has already been run)
	if err := generateResumePDF(*verbose); err != nil {
		if *verbose {
			log.Printf("Note: %v", err)
		}
	}

	// Start appropriate mode
	switch {
	case *serve:
		runServeMode("content", "config.toml", config, *verbose)
	case *watch:
		runWatchMode("content", "config.toml", config, *verbose)
	}
}

// commandExists checks if a command is available in the system PATH.
func commandExists(cmd string) bool {
	_, err := exec.LookPath(cmd)
	return err == nil
}

// loadConfig reads Hugo's config.toml and extracts D2 rendering settings.
// Returns an empty config (with safe defaults) if the file cannot be read.
// This allows the tool to run even without explicit D2 configuration.
func loadConfig(path string) *Config {
	var cfg Config
	if _, err := toml.DecodeFile(path, &cfg); err != nil {
		log.Printf("Warning: Could not load %s: %v", path, err)
	}
	return &cfg
}

// buildD2Command constructs a d2 command with rendering options from config.
//
// The command will render d2File to an SVG with the same basename.
// For example: "diagram.d2" → "diagram.svg"
//
// D2 options are applied in this order:
//   - --theme (if specified in config)
//   - --layout (if specified in config)
//   - --sketch (if enabled in config)
//   - --pad (if > 0 in config)
func buildD2Command(d2File string, config *Config) *exec.Cmd {
	args := []string{}

	// Add D2 options from config
	if theme := config.Params.D2.Theme; theme != "" {
		args = append(args, "--theme="+theme)
	}
	if layout := config.Params.D2.Layout; layout != "" {
		args = append(args, "--layout="+layout)
	}
	if config.Params.D2.Sketch {
		args = append(args, "--sketch")
	}
	if pad := config.Params.D2.Pad; pad > 0 {
		args = append(args, fmt.Sprintf("--pad=%d", pad))
	}

	// Add input and output files
	svgFile := strings.TrimSuffix(d2File, ".d2") + ".svg"
	args = append(args, d2File, svgFile)

	return exec.Command("d2", args...)
}

// renderFile renders a single D2 diagram file to SVG format.
//
// The SVG is written to the same directory with a .svg extension.
// Example: content/blog/2025-01-01/diagram.d2 → diagram.svg
//
// Returns an error if the d2 command fails. The error includes both
// the error message and any output from d2 for debugging.
func renderFile(d2File string, config *Config, verbose bool) error {
	if verbose {
		log.Printf("Rendering %s", d2File)
	} else {
		log.Printf("Rendering %s", filepath.Base(d2File))
	}

	cmd := buildD2Command(d2File, config)
	if output, err := cmd.CombinedOutput(); err != nil {
		return fmt.Errorf("%s: %v\n%s", d2File, err, output)
	}

	return nil
}

// renderAll finds and renders all D2 files in the content directory.
//
// Files are rendered concurrently for performance. Any errors are collected
// and reported after all renders complete. Returns an error if any renders fail.
//
// This is called:
//   - Once at startup (all modes)
//   - When config.toml changes (watch/serve modes)
func renderAll(contentDir string, config *Config, verbose bool) error {
	d2Files, err := findD2Files(contentDir)
	if err != nil {
		return err
	}

	if len(d2Files) == 0 {
		log.Println("No .d2 files found")
		return nil
	}

	log.Printf("Found %d D2 file(s)", len(d2Files))

	// Render all files concurrently
	var wg sync.WaitGroup
	errChan := make(chan error, len(d2Files))

	for _, file := range d2Files {
		wg.Add(1)
		go func(f string) {
			defer wg.Done()
			if err := renderFile(f, config, verbose); err != nil {
				errChan <- err
			}
		}(file)
	}

	wg.Wait()
	close(errChan)

	// Report errors
	var errCount int
	for err := range errChan {
		log.Printf("ERROR: %v", err)
		errCount++
	}

	if errCount > 0 {
		return fmt.Errorf("%d file(s) failed", errCount)
	}

	log.Println("✓ D2 rendering complete")
	return nil
}

// findD2Files recursively walks a directory tree and returns all .d2 file paths.
func findD2Files(dir string) ([]string, error) {
	var files []string
	err := filepath.Walk(dir, func(path string, info os.FileInfo, err error) error {
		if err != nil {
			return err
		}
		if !info.IsDir() && strings.HasSuffix(path, ".d2") {
			files = append(files, path)
		}
		return nil
	})
	return files, err
}

// generateResumePDF renders the resume page to PDF from Hugo's generated HTML.
//
// This function reads the already-generated public/resume/index.html file
// and uses headless Chrome to render it to PDF.
//
// The PDF is saved to public/resume.pdf alongside Hugo's other output files.
// The entire public/ directory is git-ignored.
//
// PDF generation preserves:
//   - Hugo's theme styling and layout
//   - Text as selectable text (not images) for ATS compatibility
//   - Print-optimized CSS if defined in theme
//   - All semantic HTML structure for accessibility
//
// Returns an error if the HTML file doesn't exist or PDF generation fails.
func generateResumePDF(verbose bool) error {
	resumeHTML := filepath.Join("public", "resume", "index.html")

	// Check if Hugo has generated the resume HTML
	if _, err := os.Stat(resumeHTML); os.IsNotExist(err) {
		return fmt.Errorf("resume HTML not found at %s (run Hugo first)", resumeHTML)
	}

	if verbose {
		log.Printf("Generating PDF from %s", resumeHTML)
	} else {
		log.Println("Generating resume PDF...")
	}

	// Get absolute path for file:// URL
	absPath, err := filepath.Abs(resumeHTML)
	if err != nil {
		return fmt.Errorf("failed to get absolute path: %v", err)
	}

	// Create browser context for PDF generation
	allocCtx, allocCancel := chromedp.NewExecAllocator(context.Background(),
		append(chromedp.DefaultExecAllocatorOptions[:],
			chromedp.Flag("headless", true),
			chromedp.Flag("disable-gpu", true),
			chromedp.Flag("no-sandbox", true),
		)...)
	defer allocCancel()

	browserCtx, browserCancel := chromedp.NewContext(allocCtx)
	defer browserCancel()

	// Set a timeout for PDF generation
	pdfCtx, pdfCancel := context.WithTimeout(browserCtx, 15*time.Second)
	defer pdfCancel()

	// Generate PDF with print-friendly settings
	var pdfBuf []byte
	fileURL := "file://" + absPath

	err = chromedp.Run(pdfCtx,
		chromedp.Navigate(fileURL),
		chromedp.WaitReady("body"),
		// Wait for CSS to load from file:// URL
		chromedp.Sleep(500*time.Millisecond),
		// WORKAROUND: chromedp's emulation.SetEmulatedMedia().WithMedia("print") does NOT
		// properly trigger @media print CSS rules when using file:// URLs. Testing confirmed
		// that elements remain visible (display: block) even after calling SetEmulatedMedia.
		// Therefore, we use JavaScript to prepare the page for PDF generation.
		// See: https://github.com/chromedp/chromedp/issues/941 and related discussions.
		chromedp.Evaluate(`
			// Remove navigation elements
			document.querySelectorAll('#nav-border, #nav, .skip-to-main').forEach(el => el.remove());
			// Remove footer
			document.querySelectorAll('footer').forEach(el => el.remove());
			// Remove hidden SVG icon definitions
			document.querySelectorAll('svg[display="none"], svg[style*="display: none"]').forEach(el => el.remove());
			// Remove heading anchor links (octothorpes)
			document.querySelectorAll('.heading-anchor').forEach(el => el.remove());

			// Set clean sans-serif font for PDF (overriding site's body font)
			document.body.style.fontFamily = '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif';
			document.body.style.lineHeight = '1.3rem';

			// Optimize layout for PDF
			const main = document.querySelector('#main');
			if (main) {
				main.style.marginTop = '0';
				main.style.marginBottom = '0';
			}
		`, nil),
		chromedp.ActionFunc(func(ctx context.Context) error {
			var err error
			pdfBuf, _, err = page.PrintToPDF().
				WithPrintBackground(true).
				WithPreferCSSPageSize(true).
				WithMarginTop(0.4).
				WithMarginBottom(0.4).
				WithMarginLeft(0.4).
				WithMarginRight(0.4).
				Do(ctx)
			return err
		}),
	)

	if err != nil {
		return fmt.Errorf("failed to generate PDF: %v", err)
	}

	// Write PDF directly to public directory (where Hugo output lives)
	pdfPath := filepath.Join("public", "resume.pdf")
	if err := os.WriteFile(pdfPath, pdfBuf, 0644); err != nil {
		return fmt.Errorf("failed to write PDF: %v", err)
	}

	log.Printf("✓ Resume PDF generated: %s", pdfPath)
	return nil
}

// watchResumeHTML monitors public/resume/index.html for changes and regenerates the PDF.
//
// This function watches for the resume HTML file to be created or modified by Hugo,
// then automatically regenerates static/resume.pdf from it.
//
// In development mode, Hugo rebuilds this file whenever content/resume/index.md changes.
// This watcher detects those changes and keeps the PDF in sync.
//
// The watcher runs until ctx is cancelled (when the user hits Ctrl+C).
func watchResumeHTML(ctx context.Context, verbose bool) {
	watcher, err := fsnotify.NewWatcher()
	if err != nil {
		log.Printf("Warning: Failed to create resume watcher: %v", err)
		return
	}
	defer watcher.Close()

	resumeDir := filepath.Join("public", "resume")

	// Wait for public/resume directory to exist (Hugo may not have created it yet)
	for i := 0; i < 30; i++ {
		if _, err := os.Stat(resumeDir); err == nil {
			break
		}
		select {
		case <-ctx.Done():
			return
		case <-time.After(1 * time.Second):
		}
	}

	// Watch the resume directory
	if err := watcher.Add(resumeDir); err != nil {
		log.Printf("Warning: Failed to watch resume directory: %v", err)
		return
	}

	// Debouncing: wait after last change before rendering
	var debounceTimer *time.Timer
	var debounceMu sync.Mutex

	// Generate initial PDF if the HTML already exists (handles case where Hugo
	// finished building before we started watching). This ensures PDF generation
	// happens at least once after Hugo creates the resume HTML.
	// Note: If Hugo creates the file between adding the watcher and this check,
	// we'll generate the PDF both here AND from the Create event, which is safe.
	if _, err := os.Stat(filepath.Join(resumeDir, "index.html")); err == nil {
		generateResumePDF(verbose)
	}

	// Watch for Create and Write events to regenerate PDF when resume changes
	for {
		select {
		case <-ctx.Done():
			return

		case event := <-watcher.Events:
			if event.Name == filepath.Join(resumeDir, "index.html") {
				if event.Op&(fsnotify.Write|fsnotify.Create) != 0 {
					debounceMu.Lock()
					if debounceTimer != nil {
						debounceTimer.Stop()
					}
					debounceTimer = time.AfterFunc(300*time.Millisecond, func() {
						if err := generateResumePDF(verbose); err != nil {
							log.Printf("Warning: Failed to regenerate PDF: %v", err)
						}
					})
					debounceMu.Unlock()
				}
			}

		case err := <-watcher.Errors:
			log.Printf("Resume watcher error: %v", err)
		}
	}
}

// runServeMode runs the Hugo development server with live D2 diagram and resume PDF reloading.
//
// This is the primary development mode. It:
//  1. Starts a background goroutine watching D2 files
//  2. Starts a background goroutine watching resume HTML for PDF regeneration
//  3. Starts Hugo's dev server in the foreground
//  4. Handles Ctrl+C gracefully, shutting down both processes
//
// The D2 watcher, resume watcher, and Hugo server share a context. When the user hits Ctrl+C,
// the context is cancelled, signaling all goroutines to shutdown cleanly.
//
// Hugo automatically detects when SVG files and PDFs change and triggers browser reload.
func runServeMode(contentDir, configFile string, config *Config, verbose bool) {
	if !commandExists("hugo") {
		log.Fatal("hugo is not installed. Install from https://gohugo.io/installation/")
	}

	ctx, cancel := context.WithCancel(context.Background())
	defer cancel()

	// Handle Ctrl+C gracefully
	sigChan := make(chan os.Signal, 1)
	signal.Notify(sigChan, os.Interrupt, syscall.SIGTERM)

	// Start D2 watcher in background
	go func() {
		log.Println("Starting D2 file watcher...")
		watchD2Files(ctx, contentDir, configFile, config, verbose)
	}()

	// Start resume PDF watcher in background
	go func() {
		log.Println("Starting resume PDF watcher...")
		watchResumeHTML(ctx, verbose)
	}()

	time.Sleep(500 * time.Millisecond) // Let watchers start

	// Start Hugo server
	log.Println("Starting Hugo dev server...")
	hugoCmd := exec.CommandContext(ctx, "hugo", "server", "--buildDrafts", "--noHTTPCache", "--cleanDestinationDir", "--gc", "--disableFastRender")
	hugoCmd.Stdout = os.Stdout
	hugoCmd.Stderr = os.Stderr
	hugoCmd.Stdin = os.Stdin

	if err := hugoCmd.Start(); err != nil {
		log.Fatalf("Failed to start Hugo: %v", err)
	}

	// Wait for shutdown signal
	<-sigChan
	log.Println("\nShutting down...")
	cancel()
	time.Sleep(500 * time.Millisecond)

	if hugoCmd.Process != nil {
		hugoCmd.Process.Kill()
	}
	hugoCmd.Wait()
	log.Println("Stopped")
}

// runWatchMode watches D2 files for changes without starting the Hugo server.
//
// This mode is useful when running Hugo separately (e.g., in a different terminal
// or with custom Hugo flags). The watcher will continue until interrupted with Ctrl+C.
func runWatchMode(contentDir, configFile string, config *Config, verbose bool) {
	log.Printf("Watching %s for D2 changes (Ctrl+C to stop)", contentDir)
	watchD2Files(context.Background(), contentDir, configFile, config, verbose)
}

// watchD2Files monitors the filesystem for D2 diagram and config changes.
//
// It watches:
//   - All .d2 files: re-renders the specific file on change (debounced 300ms)
//   - config.toml: re-renders ALL diagrams if [params.d2] settings change
//   - New directories: automatically adds them to the watch list
//
// The watcher runs until ctx is cancelled. In serve mode, cancellation happens
// when the user hits Ctrl+C. In watch mode, it runs indefinitely.
//
// Debouncing prevents excessive re-renders when files are saved multiple times
// rapidly (e.g., by editors that save on every keystroke).
func watchD2Files(ctx context.Context, contentDir, configFile string, config *Config, verbose bool) {
	watcher, err := fsnotify.NewWatcher()
	if err != nil {
		log.Fatalf("Failed to create watcher: %v", err)
	}
	defer watcher.Close()

	// Watch config file
	watcher.Add(configFile)

	// Watch all content directories recursively
	filepath.Walk(contentDir, func(path string, info os.FileInfo, err error) error {
		if err == nil && info.IsDir() {
			watcher.Add(path)
		}
		return nil
	})

	// Debouncing: wait 300ms after last change before rendering
	debounce := make(map[string]*time.Timer)
	var debounceMu sync.Mutex

	for {
		select {
		case <-ctx.Done():
			return

		case event := <-watcher.Events:
			// Config changed - re-render everything
			if event.Name == configFile && event.Op&fsnotify.Write != 0 {
				log.Println("Config changed - re-rendering all")
				config = loadConfig(configFile)
				renderAll(contentDir, config, verbose)
				continue
			}

			// D2 file changed - render it (debounced)
			if strings.HasSuffix(event.Name, ".d2") && event.Op&fsnotify.Write != 0 {
				debounceMu.Lock()
				if timer, exists := debounce[event.Name]; exists {
					timer.Stop()
				}
				debounce[event.Name] = time.AfterFunc(300*time.Millisecond, func() {
					renderFile(event.Name, config, verbose)
				})
				debounceMu.Unlock()
			}

			// New directory - watch it
			if event.Op&fsnotify.Create != 0 {
				if info, err := os.Stat(event.Name); err == nil && info.IsDir() {
					watcher.Add(event.Name)
				}
			}

		case err := <-watcher.Errors:
			log.Printf("Watcher error: %v", err)
		}
	}
}
